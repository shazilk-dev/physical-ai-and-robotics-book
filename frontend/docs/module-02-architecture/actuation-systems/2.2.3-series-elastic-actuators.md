---
sidebar_position: 3
title: 2.2.3 Series Elastic Actuators (SEAs)
---

# 2.2.3 Series Elastic Actuators - Compliant Force Control

## Introduction

**Problem:** Traditional robot actuators (motor + gearbox) are **stiff** - they can't sense or adapt to external forces.

**Consequence:** When a humanoid bumps into a wall, it doesn't know to stop ‚Üí damage or injury!

**Solution:** **Series Elastic Actuators (SEAs)** add a spring between the motor and output, enabling:
- ‚úÖ Force sensing (measure spring deflection)
- ‚úÖ Compliant behavior (spring absorbs impacts)
- ‚úÖ Safe human interaction (gentle touch, not rigid collision)

In this section, you'll learn how SEAs work and why they're used in robots like **Boston Dynamics' Atlas** and **Agility Robotics' Digit**.

---

## The Force Control Challenge

### Position Control vs Force Control

**Traditional Position Control:**
```
Target: "Move joint to 45¬∞"
Controller: Applies max torque until position = 45¬∞
Problem: If obstacle is at 40¬∞, motor fights it ‚Üí high forces!
```

**Force Control (with SEA):**
```
Target: "Apply 10 N force"
Controller: Measures spring deflection, adjusts motor torque
Benefit: If obstacle appears, force stays at 10 N ‚Üí safe!
```

**Real-World Example:** Humanoid shaking hands with a human.
- Position control: Robot crushes hand (doesn't know its own strength)
- Force control: Robot applies gentle 5 N grip (feels safe and natural)

---

## SEA Architecture

### Basic Structure

```
Motor ‚Üí Gearbox ‚Üí Spring ‚Üí Output (Robot Link)
                    ‚Üì
              Force Sensor (measures spring compression)
```

**Key Components:**
1. **Motor + Gearbox** (same as traditional actuators)
2. **Elastic Element** (spring, torsion bar, or rubber)
3. **Position Sensors** (encoders on both sides of spring)
4. **Force Calculation** (from spring deflection)

---

### How Force is Measured

**Hooke's Law:**
```
Force = Spring Stiffness √ó Deflection

F = k √ó Œîx

Where:
- k = Spring constant (N/m or Nm/rad)
- Œîx = Spring compression (meters or radians)
```

**In Practice:**
```
Encoder 1 (motor side): Œ∏_motor = 250¬∞
Encoder 2 (output side): Œ∏_output = 245¬∞
Deflection: ŒîŒ∏ = 250¬∞ - 245¬∞ = 5¬∞ = 0.087 rad

Spring stiffness: k = 200 Nm/rad
Torque: œÑ = 200 √ó 0.087 = 17.4 Nm
```

**Result:** Robot knows it's applying 17.4 Nm torque (even without force sensor!).

---

## Spring Design for SEAs

### Spring Stiffness Selection

**Trade-off:**

| Stiffness | Pros | Cons |
|-----------|------|------|
| **High (stiff spring)** | Better position control, less lag | Poor force sensitivity, less compliance |
| **Low (soft spring)** | Excellent force sensing, very compliant | Poor position accuracy, slow response |

**Design Rule:**
```
Choose k such that:
- Max spring deflection < 10% of joint range
- Force resolution < 1% of max force

Example:
Max force: 100 N
Desired resolution: 1 N
Encoder resolution: 0.1¬∞ = 0.00175 rad
Required stiffness: k > 1 N / 0.00175 rad = 571 N/rad
```

---

### Spring Types

**1. Coil Spring (Linear Motion)**
```
k = (G √ó d‚Å¥) / (8 √ó D¬≥ √ó N)

Where:
- G = Shear modulus (steel: 80 GPa)
- d = Wire diameter
- D = Coil diameter
- N = Number of active coils
```

**Pros:** Cheap ($5-20), standard sizes
**Cons:** Bulky, wear over time

---

**2. Torsion Spring (Rotational Joints)**
```
k = (E √ó d‚Å¥) / (3.6 √ó D √ó N)

Where:
- E = Young's modulus (steel: 200 GPa)
- d = Wire diameter
- D = Coil diameter
- N = Number of active coils
```

**Pros:** Compact for rotary joints
**Cons:** Custom fabrication needed

---

**3. Elastomer (Rubber)**
```
k depends on:
- Material (urethane, silicone)
- Geometry (thickness, area)
- Preload

Typical range: 10-500 N/m (very soft!)
```

**Pros:** Excellent damping (absorbs vibrations), safe
**Cons:** Nonlinear stiffness (hard to model), temperature-sensitive

---

**4. Leaf Spring (Metal Flexure)**
```
k = (E √ó b √ó t¬≥) / (4 √ó L¬≥)

Where:
- E = Young's modulus (steel: 200 GPa)
- b = Width
- t = Thickness
- L = Length
```

**Pros:** No friction (metal doesn't rub), long life (>1M cycles)
**Cons:** Limited deflection (&lt;5¬∞), expensive to machine

---

### Example: SEA for Humanoid Knee

**Requirements:**
- Max torque: 100 Nm
- Max deflection: 5¬∞ (to maintain position accuracy)
- Force resolution: 0.5 Nm

**Spring Selection:**
```
Required stiffness:
k = Max torque / Max deflection
k = 100 Nm / (5¬∞ √ó œÄ/180) = 100 / 0.087 = 1150 Nm/rad

Verify resolution:
Encoder: 0.05¬∞ = 0.00087 rad
Force resolution = k √ó 0.00087 = 1150 √ó 0.00087 = 1.0 Nm ‚úÖ (meets 0.5 Nm requirement)
```

**Implementation:**
- Torsion spring (steel, custom-made)
- Wire diameter: 8mm
- Coil diameter: 60mm
- Active coils: 3
- Cost: $80 (custom machining) + $30 (spring fabrication)

---

## Control Strategies for SEAs

### 1. Impedance Control

**Goal:** Make robot behave like a programmable spring-damper.

**Equation:**
```
œÑ = k_p √ó (Œ∏_desired - Œ∏_actual) + k_d √ó (œâ_desired - œâ_actual)

Where:
- k_p = Virtual spring stiffness
- k_d = Virtual damping coefficient
- Œ∏ = Position
- œâ = Velocity
```

**Behavior:**
```
High k_p: Stiff behavior (resists deflection)
Low k_p: Compliant behavior (easily pushed)
High k_d: Damped (smooth motion, no oscillation)
Low k_d: Undamped (bouncy, oscillates)
```

**Example: Humanoid Balancing**
```
Standing still: k_p = 500 Nm/rad (stiff ankle)
Catching fall: k_p = 50 Nm/rad (compliant ankle absorbs impact)
```

---

### 2. Force Control

**Goal:** Maintain constant force output regardless of position.

**Algorithm:**
```python
def force_controller(target_force, spring_k, dt=0.001):
    """
    Simple force controller for SEA
    dt = control loop period (1ms = 1 kHz)
    """
    # Read encoders
    theta_motor = read_encoder_motor()
    theta_output = read_encoder_output()

    # Calculate spring deflection
    deflection = theta_motor - theta_output

    # Measure current force
    current_force = spring_k * deflection

    # PID control (simplified: P-only for clarity)
    error = target_force - current_force
    Kp = 0.1  # Proportional gain (tune this!)

    # Adjust motor position to change force
    motor_command = theta_motor + (error / spring_k) * Kp

    # Send command to motor
    set_motor_position(motor_command)

    return current_force

# Example usage
target_force = 50  # Nm (desired torque)
spring_stiffness = 1000  # Nm/rad

while True:
    actual_force = force_controller(target_force, spring_stiffness)
    print(f"Target: {target_force} Nm | Actual: {actual_force:.1f} Nm")
    time.sleep(0.001)  # 1 kHz control loop
```

---

### 3. Hybrid Position/Force Control

**Goal:** Control position in some directions, force in others.

**Example: Polishing a surface**
```
X-Y plane: Position control (follow path)
Z-axis: Force control (apply 10 N downward pressure)
```

**Implementation:**
```python
def hybrid_controller(pos_target, force_target, spring_k):
    """
    Hybrid control: position in X-Y, force in Z
    """
    # Position control for X-Y
    x_error = pos_target['x'] - current_pos['x']
    y_error = pos_target['y'] - current_pos['y']

    x_command = Kp_pos * x_error
    y_command = Kp_pos * y_error

    # Force control for Z
    z_deflection = encoder_motor_z - encoder_output_z
    current_force_z = spring_k * z_deflection
    force_error = force_target - current_force_z

    z_command = encoder_motor_z + (force_error / spring_k) * Kp_force

    return (x_command, y_command, z_command)
```

---

## Real-World SEA Implementations

### Case Study 1: Boston Dynamics Atlas

**SEA Configuration (Legs):**
```
Hip: SEA with k = 2000 Nm/rad
Knee: SEA with k = 1500 Nm/rad
Ankle: Stiff actuator (no SEA) - for ground reaction force
```

**Why SEAs in hips/knees?**
- Absorb landing impacts (reduces peak forces by 50%)
- Enable dynamic walking (spring stores/releases energy)
- Safe human interaction (can be pushed without falling)

**Performance:**
```
Jump height: 1.2m
Landing force: ~3√ó body weight (reduced from 6√ó without SEAs)
Energy efficiency: 15% better than stiff actuators (spring recycling)
```

---

### Case Study 2: Agility Robotics Digit

**SEA Configuration:**
```
All leg joints: SEAs with variable stiffness
- Hip: k = 1800 Nm/rad
- Knee: k = 1200 Nm/rad
- Ankle: k = 800 Nm/rad (lower for ground compliance)
```

**Unique Feature:** **Fiberglass leaf springs** (instead of metal)
- Weight: 40% lighter than steel
- Damping: Natural vibration absorption (no need for active damping)
- Cost: $200 per spring (vs $80 for steel, but worth it for weight savings)

**Result:** Digit can walk on uneven terrain without falling (compliant ankles adapt to rocks, grass).

---

## DIY SEA Design

### Budget SEA for Lab 4

**Goal:** Build a simple SEA for motor control lab (< $100 total).

**Components:**
```
1. Motor: Brushless DC (T-Motor 2216, $35)
2. Gearbox: Planetary 10:1 ($40)
3. Spring: Torsion spring (McMaster-Carr, $15)
4. Encoders: 2√ó AS5048 magnetic encoders ($24)
5. Motor ESC: SimpleFOC ($30)
6. Mechanical coupling: 3D printed ($5)

Total: $149 (slightly over, but doable!)
```

---

### Step-by-Step Build Guide

**Step 1: Mechanical Design**

```
3D print housing with two sections:
- Motor Section: Mounts motor + gearbox + encoder 1
- Output Section: Mounts torsion spring + encoder 2 + output shaft

Spring connects the two sections (allows relative rotation)
```

**CAD Tip:** Use **Fusion 360** (free for hobbyists) with design similar to:
```
[ Motor ] ‚îÄ‚Üí [ Gearbox ] ‚îÄ‚Üí [ Encoder 1 ] ‚îÄ‚Üí [ Spring ] ‚îÄ‚Üí [ Encoder 2 ] ‚îÄ‚Üí [ Output Shaft ]
                                                    ‚Üë
                                             Compliance here!
```

---

**Step 2: Spring Sizing**

```
Target specs:
- Max torque: 5 Nm (suitable for small robot arm)
- Max deflection: 10¬∞ = 0.175 rad
- Stiffness: k = 5 Nm / 0.175 rad = 28.6 Nm/rad

Torsion spring calculator (online tool):
- Wire diameter: 3mm
- Coil diameter: 20mm
- Active coils: 8
- Material: Music wire (ASTM A228)

Result: k = 30 Nm/rad ‚úÖ (close enough!)
Order from: McMaster-Carr #9271K83 ($12)
```

---

**Step 3: Encoder Mounting**

**Critical:** Encoders must be perfectly aligned (coaxial with rotation axis).

```
Encoder 1 (motor side):
- Mount magnet to gearbox output shaft
- Mount PCB to motor housing (3mm air gap from magnet)

Encoder 2 (output side):
- Mount magnet to output shaft
- Mount PCB to output housing (3mm air gap from magnet)

Calibration:
- Rotate spring by hand through full range
- Record encoder readings at both ends
- Verify difference = spring deflection
```

---

**Step 4: Software (ROS 2 Node)**

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64
import spidev

class SEAController(Node):
    """Series Elastic Actuator controller"""

    def __init__(self):
        super().__init__('sea_controller')

        # Spring constant (Nm/rad)
        self.spring_k = 30.0

        # Control gains
        self.Kp_force = 0.5
        self.Ki_force = 0.01

        # State
        self.target_force = 0.0
        self.integral_error = 0.0

        # Hardware
        self.setup_encoders()

        # ROS 2 interface
        self.sub_force = self.create_subscription(
            Float64, 'target_force', self.force_callback, 10
        )
        self.pub_actual_force = self.create_publisher(Float64, 'actual_force', 10)

        # Control loop at 500 Hz
        self.timer = self.create_timer(0.002, self.control_loop)

    def setup_encoders(self):
        """Initialize SPI for dual encoders"""
        self.spi_motor = spidev.SpiDev()
        self.spi_motor.open(0, 0)  # Motor-side encoder

        self.spi_output = spidev.SpiDev()
        self.spi_output.open(0, 1)  # Output-side encoder

    def read_encoder(self, spi):
        """Read AS5048 encoder angle (radians)"""
        data = spi.xfer2([0xFF, 0xFF])
        raw = ((data[0] & 0x3F) << 8) | data[1]
        angle_rad = (raw / 16384.0) * 2 * 3.14159
        return angle_rad

    def force_callback(self, msg):
        """Update target force"""
        self.target_force = msg.data

    def control_loop(self):
        """Force control loop"""
        # Read both encoders
        theta_motor = self.read_encoder(self.spi_motor)
        theta_output = self.read_encoder(self.spi_output)

        # Calculate spring deflection
        deflection = theta_motor - theta_output

        # Calculate actual force (Hooke's law)
        actual_force = self.spring_k * deflection

        # Force error
        error = self.target_force - actual_force
        self.integral_error += error * 0.002  # dt = 2ms

        # PI control (no derivative to avoid noise)
        control_output = (self.Kp_force * error +
                          self.Ki_force * self.integral_error)

        # Adjust motor position to change force
        new_motor_target = theta_motor + (control_output / self.spring_k)

        # Send command to motor controller (via CAN or PWM)
        self.send_motor_command(new_motor_target)

        # Publish actual force for monitoring
        msg = Float64()
        msg.data = actual_force
        self.pub_actual_force.publish(msg)

        # Log (every 100ms)
        if self.get_clock().now().nanoseconds % 100000000 < 2000000:
            self.get_logger().info(
                f'Target: {self.target_force:.2f} Nm | '
                f'Actual: {actual_force:.2f} Nm | '
                f'Deflection: {deflection*180/3.14:.1f}¬∞'
            )

    def send_motor_command(self, position):
        """Send position command to motor ESC (placeholder)"""
        # In real implementation, use CAN bus or PWM
        pass

def main(args=None):
    rclpy.init(args=args)
    controller = SEAController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()
```

---

## Limitations of SEAs

### When NOT to Use SEAs

**1. High-Speed Applications**
- Spring compliance introduces lag (phase delay)
- Not suitable for robots requiring > 500¬∞/s joint speed
- **Example:** Drone propeller control ‚ùå

**2. High-Precision Positioning**
- Spring deflection reduces position accuracy
- Typical SEA accuracy: ¬±0.5¬∞ (vs ¬±0.01¬∞ for rigid actuators)
- **Example:** Micro-surgery robots ‚ùå

**3. Very Low-Torque Joints**
- Spring must be very soft ‚Üí bulky spring for small deflection
- Not practical for grippers or small fingers
- **Example:** Miniature robot hands ‚ùå

---

### Alternative: Torque Sensors

**If you need force sensing without compliance:**

**Load Cell (Strain Gauge):**
```
Mounted between motor and output (rigid connection)
Measures force directly (no spring needed)

Pros: High precision, no compliance
Cons: Expensive ($200-500), fragile
```

**Current Sensing (Torque Estimation):**
```
Measure motor current ‚Üí Estimate torque (œÑ = K_t √ó I)

Pros: Free (already have current sensor in ESC)
Cons: Inaccurate (friction, inertia affect estimate)
```

**For Humanoid Robots:** SEAs are still preferred (compliance is a feature, not a bug!).

---

## Summary

### Key Takeaways

1. ‚úÖ **SEAs enable force control** by measuring spring deflection
2. ‚úÖ **Compliance improves safety** (absorbs impacts, gentle interaction)
3. ‚úÖ **Spring stiffness is a trade-off** (high k = good position, low k = good force sensing)
4. ‚úÖ **Dual encoders are required** (one on each side of spring)
5. ‚úÖ **SEAs reduce energy consumption** (spring stores/releases energy during locomotion)

---

### SEA Design Checklist

- [ ] Calculate required spring stiffness (k = max torque / max deflection)
- [ ] Select spring type (torsion for rotary joints, coil for linear)
- [ ] Ensure encoder resolution supports desired force resolution
- [ ] Implement dual encoder mounting (perfectly aligned!)
- [ ] Tune force controller gains (Kp, Ki) for stability
- [ ] Add safety limits (max deflection, max force)
- [ ] Test compliance by hand (should feel "springy," not rigid)

---

## Practice Problems

### Problem 1: Spring Stiffness Design

**Given:**
- SEA for robot elbow
- Max torque: 20 Nm
- Max deflection tolerance: 5¬∞
- Encoder resolution: 0.05¬∞

**Calculate:**
1. Required spring stiffness (k)
2. Force resolution at output
3. Is this acceptable for a manipulation task?

---

### Problem 2: Control Tuning

**Scenario:** You built an SEA but it oscillates when commanded to apply constant force.

**Question:**
1. Which PID gain is too high? (Kp, Ki, or Kd?)
2. How would you tune it?
3. What if it's too slow to respond?

---

## Further Reading

### Recommended Resources

**Papers:**
- "Design of Series Elastic Actuators for Dynamic Robots" - Pratt & Williamson (Original SEA paper, MIT 1995)
- "Variable Stiffness Actuators: A Survey" - Vanderborght et al. (Review of SEA variants)

**Books:**
- "Springer Handbook of Robotics" - Chapter 7: Actuation (SEA section)

**Videos:**
- "How Boston Dynamics' Robots Work" - Real Engineering (YouTube) - Explains SEA role in Atlas
- "Building a Series Elastic Actuator" - James Bruton (DIY guide)

---

## Next Chapter

Congratulations! You've completed **Chapter 2.2: Actuation Systems**.

You now understand:
- ‚úÖ BLDC motors and encoders
- ‚úÖ Harmonic drives and gearboxes
- ‚úÖ Series elastic actuators for force control

**Next:** **Chapter 2.3: Edge Compute Architecture** - Learn how to deploy AI models on NVIDIA Jetson for real-time perception!

Continue to **[Chapter 2.3: Edge Compute](../edge-compute/2.3.1-jetson-architecture.md)** üñ•Ô∏è‚ö°

---

**Section Status:** ‚úÖ Complete
**Estimated Reading Time:** 45 minutes
**Hands-On Project:** 4-6 hours (DIY SEA build, optional)
