---
sidebar_position: 1
title: 2.2.1 Servo Motors & Encoders
---

# 2.2.1 Servo Motors & Encoders - The Muscles of Robots

## Introduction

**Analogy:** If robot links are the "bones" (Chapter 2.1), then **motors are the muscles** that move them.

In this section, you'll learn:
- How brushless DC (BLDC) motors work
- How to select motors based on torque, speed, and power requirements
- How encoders provide position feedback for closed-loop control
- Real-world motor specifications from humanoid robots

By the end, you'll be able to **spec a motor for any robot joint**.

---

## Motor Fundamentals

### DC Motor Types Comparison

| Motor Type | Torque | Speed | Efficiency | Cost | Control Complexity |
|------------|--------|-------|------------|------|-------------------|
| **Brushed DC** | Medium | High | 75-80% | $ | Simple (2 wires) |
| **Brushless DC (BLDC)** | High | High | 85-90% | $$ | Medium (ESC required) |
| **Stepper** | Low | Low | 50-70% | $ | Simple (pulse control) |
| **Servo (RC)** | Low | Medium | 75% | $ | Simple (PWM signal) |

**For Humanoid Robots:** **BLDC motors** are the industry standard (Tesla Optimus, Unitree G1, Figure 02).

---

### Why BLDC Motors Win

**Advantages:**
- âœ… **High efficiency** (85-90% â†’ less battery drain, less heat)
- âœ… **High power density** (3-5 kW/kg for good motors)
- âœ… **No brushes** â†’ longer lifespan (>10,000 hours)
- âœ… **Precise control** with encoders (position accuracy < 0.1Â°)
- âœ… **Scalable** (same technology works from 10W to 10kW)

**Disadvantages:**
- âŒ **Requires ESC (Electronic Speed Controller)** â†’ adds cost + complexity
- âŒ **Needs encoder** for position control (extra sensor)
- âŒ **More expensive** than brushed ($100-500 vs $20-50)

---

## BLDC Motor Operation

### How They Work (Simplified)

**Key Components:**
1. **Stator** (stationary part) - Electromagnetic coils
2. **Rotor** (rotating part) - Permanent magnets
3. **Hall Sensors** (optional) - Detect rotor position for commutation

**Operating Principle:**
```
Step 1: Energize coil A â†’ Rotor turns 60Â°
Step 2: Energize coil B â†’ Rotor turns another 60Â°
Step 3: Energize coil C â†’ Rotor turns another 60Â°
Repeat â†’ Continuous rotation
```

**Commutation:** Switching which coils are energized (handled by ESC automatically).

---

### Key Motor Specifications

**1. KV Rating (RPM per Volt)**

```
RPM = KV Ã— Voltage

Example:
Motor: 1000 KV
Voltage: 24V
Max RPM = 1000 Ã— 24 = 24,000 RPM
```

**Rule of Thumb:**
- High KV (>1500) â†’ Fast, low torque (drones, fans)
- Low KV (<500) â†’ Slow, high torque (robot joints)

**For Humanoids:** Use 100-300 KV motors (high torque needed).

---

**2. Torque Constant (K_t)**

Relates current to torque:
```
Torque (Nm) = K_t Ã— Current (A)

Example:
K_t = 0.05 Nm/A
Current = 20A
Torque = 0.05 Ã— 20 = 1.0 Nm
```

**Important:** K_t and KV are inversely related:
```
K_t â‰ˆ 8.3 / KV  (approximate formula)
```

---

**3. Continuous vs Peak Torque**

- **Continuous Torque:** Can be sustained indefinitely (thermal limit)
- **Peak Torque:** Maximum for short bursts (< 1 second)

**Example: T-Motor U8 II (used in some humanoid prototypes)**
```
Continuous Torque: 2.0 Nm
Peak Torque: 6.5 Nm (3.25Ã— higher!)
```

**Design Implication:** Size motor for continuous torque, not peak (to avoid overheating).

---

**4. Power Rating**

```
Power (W) = Torque (Nm) Ã— Angular Velocity (rad/s)

Example:
Torque = 2.0 Nm
Speed = 1000 RPM = 104.7 rad/s
Power = 2.0 Ã— 104.7 = 209 W
```

**Typical Humanoid Motor Power:**
- Gripper: 10-50W
- Wrist/elbow: 50-150W
- Shoulder/hip: 150-500W
- Knee: 300-800W

---

## Motor Sizing for Robot Joints

### Step-by-Step Method

**Example:** Design a motor for robot elbow joint.

**Step 1: Calculate Required Torque**

```
Torque = Force Ã— Moment Arm

Given:
- Forearm mass: 0.5 kg
- Forearm length: 0.25 m
- Payload: 1.0 kg at end of forearm
- Gravity: 9.81 m/sÂ²

Torque from forearm:
Ï„_forearm = (0.5 kg Ã— 9.81) Ã— (0.25/2) m = 0.61 Nm

Torque from payload:
Ï„_payload = (1.0 kg Ã— 9.81) Ã— 0.25 m = 2.45 Nm

Total torque (static):
Ï„_total = 0.61 + 2.45 = 3.06 Nm
```

---

**Step 2: Add Dynamic Torque**

For acceleration:
```
Ï„_dynamic = I Ã— Î±

Where:
- I = Moment of inertia (kgÂ·mÂ²)
- Î± = Angular acceleration (rad/sÂ²)

Simplified (treat as point mass):
I = m Ã— rÂ² = 1.5 kg Ã— (0.125 m)Â² = 0.023 kgÂ·mÂ²

Desired acceleration: 180Â°/sÂ² = 3.14 rad/sÂ²
Ï„_dynamic = 0.023 Ã— 3.14 = 0.07 Nm (small!)
```

---

**Step 3: Add Safety Factor**

```
Ï„_required = (Ï„_static + Ï„_dynamic) Ã— Safety Factor
Ï„_required = (3.06 + 0.07) Ã— 2.0 = 6.26 Nm
```

**Safety factor rationale:**
- 2.0Ã— for smooth operation (not running at max power)
- Accounts for friction, gear inefficiency
- Provides margin for unexpected loads

---

**Step 4: Select Motor + Gearbox**

**Option A: Direct Drive (No Gearbox)**
- Need motor with 6.26 Nm continuous torque
- Such motors are huge and expensive ($500+)
- âŒ **Not practical**

**Option B: Motor + Gear Reduction**
```
Gearbox ratio: 50:1
Motor torque needed: 6.26 / 50 = 0.125 Nm

Suitable motor: Turnigy RotoMax 50cc (50W, 0.15 Nm continuous)
Cost: $80
Gearbox (planetary, 50:1): $60
Total: $140 âœ…
```

**Trade-off:** Gearbox adds weight (200g) but dramatically reduces motor size/cost.

---

## Encoders - The Robot's Sense of Position

### Why Encoders are Essential

**Open-Loop Control (No Encoder):**
```
Send motor "20% power" â†’ Hope it moves to correct position â†’ Pray! ðŸ¤ž
```
**Problem:** Motor position depends on load, friction, battery voltage â†’ highly inaccurate!

**Closed-Loop Control (With Encoder):**
```
1. Read encoder: Current position = 45Â°
2. Target position = 90Â°
3. Error = 90Â° - 45Â° = 45Â°
4. Apply torque proportional to error (PID control)
5. Repeat at 1 kHz â†’ Precise positioning! âœ…
```

---

### Encoder Types

| Type | Resolution | Cost | Interface | Applications |
|------|-----------|------|-----------|--------------|
| **Incremental** | 100-10,000 CPR | $10-50 | Quadrature (2 channels) | General robotics |
| **Absolute (Magnetic)** | 12-14 bits (0.09Â°) | $30-100 | SPI, I2C | Robot joints (no homing needed) |
| **Absolute (Optical)** | 16-20 bits (0.001Â°) | $200-1000 | Serial | CNC machines, precision robotics |

**For Humanoid Robots:** **Magnetic absolute encoders** (AS5048, MA730) are best (affordable, no homing required).

---

### Incremental Encoder Resolution

**CPR (Counts Per Revolution):**
```
Angular resolution = 360Â° / CPR

Example:
Encoder: 2048 CPR
Resolution = 360Â° / 2048 = 0.176Â° â‰ˆ 0.18Â°
```

**With Quadrature Decoding:** 4Ã— resolution (count rising + falling edges on both channels)
```
Effective CPR = 2048 Ã— 4 = 8192
Resolution = 360Â° / 8192 = 0.044Â° âœ…
```

**Typical Requirements:**
- Gripper: 0.5Â° resolution (500 CPR encoder)
- Arm joints: 0.1Â° resolution (2000 CPR encoder)
- Precision joints: 0.01Â° resolution (20,000 CPR encoder or absolute)

---

### Absolute Encoder Advantages

**Key Benefit:** Knows position even after power-off (no homing sequence needed).

**Example: AS5048 Magnetic Encoder**
```
Resolution: 14-bit (16,384 positions)
Angular resolution: 360Â° / 16,384 = 0.022Â°
Interface: SPI (10 MHz clock â†’ 10 kHz update rate)
Cost: $12 per encoder
Power: 3.3V @ 10 mA
```

**Wiring (SPI):**
```
Arduino/Jetson        AS5048 Encoder
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     3.3V     â”€â”€â”€â”€â”€â†’  VDD
     GND      â”€â”€â”€â”€â”€â†’  GND
     SCK      â”€â”€â”€â”€â”€â†’  CLK (clock)
     MOSI     â”€â”€â”€â”€â”€â†’  (not used)
     MISO     â†â”€â”€â”€â”€â”€  DO (data out)
     CS       â”€â”€â”€â”€â”€â†’  CS (chip select)
```

---

## Motor Selection Case Studies

### Case Study 1: Unitree G1 Knee Motor

**Requirements:**
- Support full robot weight: 35 kg Ã— 9.81 = 343 N
- Knee-to-CoM distance: ~0.3m (worst case: standing on one leg)
- Required torque: 343 N Ã— 0.3 m = 103 Nm
- Desired speed: 180Â°/s (3.14 rad/s)

**Solution:**
```
Motor: Custom BLDC (Unitree proprietary)
Peak torque: 30 Nm
Gear reduction: Harmonic drive, 4.3:1 ratio
Output torque: 30 Nm Ã— 4.3 = 129 Nm âœ…
Weight: 850g (motor + gearbox)
```

**Key Design Choice:** Harmonic drive instead of planetary gearbox for:
- Zero backlash (precise position control)
- High torque density (compact)
- Single-stage reduction (less complexity)

---

### Case Study 2: Figure 02 Wrist Motor

**Requirements:**
- Payload: 5 kg object at 0.15m from wrist
- Required torque: 5 kg Ã— 9.81 Ã— 0.15 m = 7.4 Nm
- High-speed motion: 360Â°/s (6.28 rad/s)

**Solution:**
```
Motor: T-Motor U8 II
Continuous torque: 2.0 Nm
Gear reduction: Planetary, 5:1 ratio
Output torque: 2.0 Nm Ã— 5 Ã— 0.85 (efficiency) = 8.5 Nm âœ…
Output speed: (24,000 RPM / 1000 KV) / 5 = 4,800 RPM = 502 rad/s
Cost: $180 (motor) + $85 (gearbox) = $265
```

**Design Trade-off:** High-speed motor with low gear ratio â†’ fast wrist motion, adequate torque.

---

## ESC (Electronic Speed Controller)

### What ESCs Do

**Functions:**
1. **Commutation** - Switch motor phases in correct sequence
2. **Current Control** - Limit current to prevent motor burnout
3. **Speed/Torque Control** - Convert PWM/CAN commands to motor drive signals
4. **Regenerative Braking** - Recover energy when motor decelerates

---

### ESC Selection Criteria

| Parameter | Typical Value | Notes |
|-----------|---------------|-------|
| **Continuous Current** | 20-60A | Must exceed motor continuous current |
| **Voltage Range** | 12-48V | Match robot battery voltage |
| **Control Interface** | PWM, CAN, UART | CAN preferred for multi-motor systems |
| **Firmware** | Field-Oriented Control (FOC) | Smooth, efficient motor drive |
| **Telemetry** | Current, voltage, temp | Critical for safety monitoring |

**Recommended ESCs for Humanoids:**
- **VESC (Vedder ESC)** - Open-source, FOC, CAN bus ($120)
- **ODrive** - Dual-motor, high-power, ROS 2 integration ($149)
- **SimpleFOC** - DIY-friendly, Arduino-based ($ 40)

---

### VESC Configuration Example

```yaml
motor_config:
  motor_type: BLDC
  pole_pairs: 7  # Count magnets / 2
  resistance: 0.05  # Ohms (measure with multimeter)
  inductance: 0.00005  # H (from datasheet)
  kv_rating: 200  # RPM/V

encoder_config:
  type: AS5048A
  interface: SPI
  resolution: 16384  # 14-bit

control_config:
  mode: Current  # or Speed, Position
  max_current: 40A  # Peak motor current
  max_erpm: 48000  # Max electrical RPM = KV Ã— V Ã— pole_pairs
```

**Tuning:** Run VESC detection wizard â†’ Auto-measures R, L, flux linkage.

---

## Power Transmission: Motor to Joint

### Coupling Methods

**Method 1: Direct Drive**
- Motor shaft directly connected to joint
- **Pros:** Zero backlash, simple
- **Cons:** Huge motors needed (impractical for humanoids)

**Method 2: Belt Drive**
- Timing belt connects motor pulley to joint pulley
- **Pros:** Flexible placement (motor can be remote), shock absorption
- **Cons:** Belt stretch (position error), maintenance (belt replacement)

**Method 3: Gear Reduction**
- Planetary or harmonic gearbox between motor and joint
- **Pros:** High torque multiplication, compact
- **Cons:** Backlash (planetary), expensive (harmonic), efficiency loss (15-30%)

**Industry Standard:** Harmonic drives for precision joints, planetary gears for high-speed joints.

---

## Motor Thermal Management

### The Heat Problem

**Power Loss:**
```
P_loss = IÂ² Ã— R + (Torque Ã— Speed) Ã— (1 - Efficiency)

Example:
Current: 30A
Resistance: 0.05 Î©
Motor losses: 30Â² Ã— 0.05 = 45W of heat!
```

**Thermal Time Constant:**
- Small motors (50W): Heat up in 30 seconds
- Large motors (500W): Heat up in 5 minutes

**Failure Mode:** Overheating â†’ Demagnetization of permanent magnets â†’ Motor death ðŸ’€

---

### Cooling Solutions

**Passive Cooling (Budget Option):**
- Aluminum motor housing (acts as heat sink)
- Thermal paste between motor and robot link
- **Effective for:** <150W continuous power

**Active Cooling (Professional):**
- Small axial fan (5V, 0.5W) mounted on motor
- Forced air through motor fins
- **Effective for:** 150-500W continuous

**Liquid Cooling (Extreme):**
- Water jacket around motor stator
- Pump + radiator system
- **Effective for:** >500W (Tesla Optimus uses this for hip motors)

---

## Coding Example: Motor Control with Encoder Feedback

### Position Control Loop (Python + ROS 2)

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64
import spidev  # For AS5048 encoder
import RPi.GPIO as GPIO  # For PWM motor control

class MotorController(Node):
    """Simple PID position controller for BLDC motor with encoder"""

    def __init__(self):
        super().__init__('motor_controller')

        # PID gains (tune these!)
        self.Kp = 0.5  # Proportional gain
        self.Ki = 0.01  # Integral gain
        self.Kd = 0.05  # Derivative gain

        # State variables
        self.target_position = 0.0  # Target angle (degrees)
        self.current_position = 0.0  # Current angle (degrees)
        self.integral_error = 0.0
        self.last_error = 0.0

        # Hardware setup
        self.setup_encoder()  # Initialize SPI for AS5048
        self.setup_motor()    # Initialize PWM for motor control

        # ROS 2 subscriber for target position
        self.sub = self.create_subscription(
            Float64, 'joint_target', self.target_callback, 10
        )

        # Control loop timer (1 kHz = 1ms period)
        self.timer = self.create_timer(0.001, self.control_loop)

    def setup_encoder(self):
        """Initialize SPI connection to AS5048 encoder"""
        self.spi = spidev.SpiDev()
        self.spi.open(0, 0)  # Bus 0, device 0
        self.spi.max_speed_hz = 1000000  # 1 MHz

    def setup_motor(self):
        """Initialize PWM for motor ESC control"""
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(18, GPIO.OUT)  # PWM pin
        self.motor_pwm = GPIO.PWM(18, 1000)  # 1 kHz PWM frequency
        self.motor_pwm.start(50)  # Start at 50% duty cycle (neutral)

    def read_encoder(self):
        """Read angle from AS5048 magnetic encoder"""
        # Send read command (0xFFFF reads angle register)
        data = self.spi.xfer2([0xFF, 0xFF])

        # Extract 14-bit angle value
        raw_angle = ((data[0] & 0x3F) << 8) | data[1]

        # Convert to degrees (14-bit = 16384 counts)
        angle_deg = (raw_angle / 16384.0) * 360.0

        return angle_deg

    def target_callback(self, msg):
        """Update target position from ROS 2 topic"""
        self.target_position = msg.data
        self.get_logger().info(f'New target: {self.target_position:.2f}Â°')

    def control_loop(self):
        """PID control loop running at 1 kHz"""
        # Read current position
        self.current_position = self.read_encoder()

        # Calculate error
        error = self.target_position - self.current_position

        # Handle angle wrapping (-180 to 180)
        if error > 180:
            error -= 360
        elif error < -180:
            error += 360

        # PID calculations
        self.integral_error += error * 0.001  # dt = 1ms
        derivative_error = (error - self.last_error) / 0.001

        # Anti-windup (limit integral)
        if abs(self.integral_error) > 100:
            self.integral_error = 100 * (1 if self.integral_error > 0 else -1)

        # PID output (motor command)
        output = (self.Kp * error +
                  self.Ki * self.integral_error +
                  self.Kd * derivative_error)

        # Clamp output to PWM range (0-100%)
        output = max(0, min(100, 50 + output))  # Offset by 50 (neutral)

        # Send PWM command to motor
        self.motor_pwm.ChangeDutyCycle(output)

        # Store error for next iteration
        self.last_error = error

        # Log status (every 100ms)
        if self.get_clock().now().nanoseconds % 100000000 < 1000000:
            self.get_logger().info(
                f'Pos: {self.current_position:.2f}Â° | '
                f'Target: {self.target_position:.2f}Â° | '
                f'Error: {error:.2f}Â° | '
                f'Output: {output:.1f}%'
            )

def main(args=None):
    rclpy.init(args=args)
    controller = MotorController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.motor_pwm.stop()
        GPIO.cleanup()
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Key Features:**
- 1 kHz control loop (industry standard for servo control)
- PID algorithm with anti-windup
- Angle wrapping for continuous rotation
- ROS 2 integration for command input

---

## Summary

### Key Takeaways

1. âœ… **BLDC motors** are ideal for humanoid robots (high efficiency, precise control)
2. âœ… **Motor torque = K_t Ã— Current** - Select motors based on required torque
3. âœ… **Gear reduction** multiplies torque but reduces speed
4. âœ… **Absolute encoders** (AS5048) eliminate homing, improve reliability
5. âœ… **PID control at 1 kHz** is standard for precise position control

---

### Motor Selection Checklist

- [ ] Calculate required torque (static + dynamic + safety factor)
- [ ] Select motor with adequate continuous torque rating
- [ ] Choose gear ratio to match speed/torque requirements
- [ ] Select encoder with resolution < 0.1Â° for precision joints
- [ ] Verify ESC current rating exceeds motor peak current
- [ ] Plan thermal management (heat sink, fan, or liquid cooling)

---

## Practice Problems

### Problem 1: Motor Sizing

**Given:**
- Robot shoulder needs to lift 3 kg arm extended 0.4m
- Desired angular acceleration: 2 rad/sÂ²
- Moment of inertia: 0.05 kgÂ·mÂ²

**Calculate:**
1. Static torque required
2. Dynamic torque required
3. Total torque with 2Ã— safety factor
4. Motor + gearbox configuration

---

### Problem 2: Encoder Resolution

**Question:** You need 0.5Â° position accuracy at the end-effector.

Given:
- Gear ratio: 10:1
- What is the minimum encoder resolution (CPR) required at the motor?

**Hint:** Account for gear reduction!

---

## Further Reading

### Recommended Resources

**Books:**
- "Brushless Permanent Magnet Motor Design" - Hanselman
- "Electric Motors and Drives" - Austin Hughes

**Online:**
- **VESC Documentation:** https://vesc-project.com/
- **ODrive Documentation:** https://docs.odriverobotics.com/

**Videos:**
- "How BLDC Motors Work" - Lesics (YouTube)
- "PID Control Explained" - MATLAB Tech Talks

---

## Next Section

Now that you understand motors, it's time to learn about **gear reduction** systems that multiply torque.

Continue to **[Section 2.2.2: Harmonic Drives & Gear Reduction](./2.2.2-harmonic-drives.md)** to discover why humanoids use special "harmonic drive" gearboxes! âš™ï¸ðŸ¦¾

---

**Section Status:** âœ… Complete
**Estimated Reading Time:** 50 minutes
**Hands-On Coding:** 40 minutes (requires Arduino + motor + encoder)
